from fastapi import APIRouter, Query, Depends, HTTPException, Path
from sqlalchemy.orm import Session
from pydantic import BaseModel
from typing import List
from ..db.database import SessionLocal
from ..db.models import Room, Player, RoomStatus, Game, CardsXGame, CardState
from app.sockets.socket_service import get_websocket_service

router = APIRouter(prefix="/api", tags=["API"])

# Conexi√≥n a la DB
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# Modelos de respuesta
class GameItem(BaseModel):
    id: int
    name: str
    player_qty: int
    players_joined: int
    host_id: int | None 

    model_config = {"from_attributes": True}

class GameListResponse(BaseModel):
    items: List[GameItem]
    page: int
    limit: int

# Endpoint: POST /game/{id}/skip
@router.post("/game/{game_id}/skip")
async def skip_turn(
    game_id: int = Path(..., description="ID de la partida"),
    user_id: int = 1, # token/auth, pero por ahora es 1
    db: Session = Depends(get_db)
):
    # Busca la patrida
    game = db.query(Game).filter(Game.id == game_id).first()
    if not game:
        raise HTTPException(status_code=404, detail="game_not_found")

    # Validar turno
    if game.player_turn_id != user_id:
        raise HTTPException(status_code=403, detail="not_your_turn")
    
    # Buscar cartas en la mano del jugador
    hand_cards = (
        db.query(CardsXGame).filter(
            CardsXGame.id_game == game_id,
            CardsXGame.player_id == user_id,
            CardsXGame.is_in == CardState.HAND
        ).order_by(CardsXGame.position.asc()).all()
    )

    if not hand_cards:
      raise HTTPException(status_code=400, detail="empty_hand")

    # Descartar primera carta
    discarded = hand_cards[0]
    discarded.is_in = CardState.DISCARD
    discarded.player_id = None
    db.add(discarded)

    # Robar del mazo la carta con menor posicion en el deck
    new_card = (
      db.query(CardsXGame).filter(
          CardsXGame.id_game == game_id,
          CardsXGame.is_in == CardState.DECK
      ).order_by(CardsXGame.position.asc()).first()
    )

    if not new_card:
        raise HTTPException(status_code=400, detail="deck_empty")

    new_card.is_in = CardState.HAND
    new_card.player_id = user_id
    db.add(new_card)

    # Avanzar turno (busco jugadores en la room)
    room = db.query(Room).filter(Room.id_game == game_id).first()
    players = db.query(Player).filter(Player.id_room == room.id).order_by(Player.order.asc()).all()
    player_ids = [p.id for p in players]
    idx = player_ids.index(user_id)
    next_turn = player_ids[(idx + 1) % len(player_ids)]
    game.player_turn_id = next_turn

    db.commit()
    db.refresh(game)

    # Emitir por websocket
    ws_service = get_websocket_service()
    await ws_service.notificar_estado_partida(
        game_id=game_id,
        jugador_que_actuo=user_id,
        game_state={
            "turno_actual": game.player_turn_id,
            "jugadores": player_ids,
            "mazos": {
                "regular": db.query(CardsXGame).filter(
                    CardsXGame.id_game == game_id, CardsXGame.is_in == CardState.DECK
                ).count(),
                "descarte": db.query(CardsXGame).filter(
                    CardsXGame.id_game == game_id, CardsXGame.is_in == CardState.DISCARD
                ).count(),
            },
            "manos": {
                user_id: [
                    c.id for c in db.query(CardsXGame).filter(
                        CardsXGame.id_game == game_id,
                        CardsXGame.player_id == user_id,
                        CardsXGame.is_in == CardState.HAND
                    )
                ]
            },
        }
    )

    return {
        "status": "ok",
        "discarded_card_id": discarded.id,
        "new_card_id": new_card.id,
        "next_turn": next_turn
    }
